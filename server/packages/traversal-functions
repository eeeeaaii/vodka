v2:~(|package @traversal ~"bind to"(_@in--when--do &" nex testf& dof&"(|~(|if ~(_testf @nex_) ~(_dof @nex_) ~(|if ~(_is-list @nex_) ~(|if ~(_is-empty @nex_) @nex ~"push into"(|~"in when do"(_~(_head @nex_) @testf @dof_) ~"in when do"(_~(_tail @nex_) @testf @dof_)|)|) @nex|)|)|)_) ~"bind to"(_@keep--only-when &" lst() testf&"(|~(_let @filtered ~"filter with"(_@lst &"n"(|~(|if ~(_is-list @n_) !yes ~(_testf @n_)|)|)_)_) ~"map with"(_@filtered &"n"(|~(|if ~(_testf @n_) @n ~(|if ~(_is-list @n_) ~"keep only-when"(_@n @testf_) @n|)|)|)_)|)_) ~"bind to"(_@in--when-atom-do &" nex f&"(|~(_let @isatom &"n"(_~(_not ~(_is-list @n_)_)_)_) ~"in when do"(_@nex @isatom @f_)|)_) ~"bind to"(_@in--when--replace-with &" nex testf& replacement"(|~(_let @dof &"n"(_~(_copy @replacement_)_)_) ~"in when do"(_@nex @testf @dof_)|)_) ~"bind to"(_@in--is-there-a &"! lst() f&"(|~(_let @hasit !no_) ~"in when do"(_@lst @f &"n"(|~(_set @hasit !yes_)|)_) @hasit|)_) ~"bind to"(_@in--is-there-the-number &"! lst() a#%"(|~"in is-there-a"(_@lst &"n"(|~(|if ~(_or ~(_is-integer @n_) ~(_is-float @n_)_) ~(_::eq:: @n @a_) !no|)|)_)|)_) ~"bind to"(_@in--when--enlist &"() lst() f&"(|~(_let @r (||)_) ~"in when do"(_@lst @f &"n"(|~(_cram @n @r_)|)_) @r|)_)|)